Luồng Thread:
- Cho phép chương trình hoạt động hiệu quả hơn bằng cách: thực hiện nhiều tác vụ cùng lúc
- Thực hiện các tác vụ phức tạp trong nền mà không gián đoạn chương trình chính
Creat a Thread:
- Kế thừa lơp Thread và ghi đè phương thức run của nó
- Triển khai interface runnable (Lợi hơn 1)
- Dùng Anonymous Class hoặc Lambda Expresion

* Kế thừa thread:
- B1: Tạo lớp kế thừa của lớp thread
- B2: Override phương thức run()
- B3: Khởi tạo đối tượng
- B4: Kích hoạt thread bằng cách dùng hàm start
      + Không dùng run vì nó sẽ chạy as như hàm btg mà k vào luồng
      + Sau khi kết thúc luồng thì không thể gọi lại đối tượng mà phải tạo mới
      + Nếu tạo ra 2 luồng t1,t2 cùng chạy thì thứ tự sẽ không cố định
* Kế thừa Interface Runnable:
- B1: Tạo lớp kế thừa từ Interface Runnable
- B2: Override phương thức run
- B3: Khởi tạo đối tượng:
    + Khởi tạo công việc cần làm, cần thức thi
    ten_lop nv=new tenlop();
    + Tạo "máy" thực hiện công việc trên
    Thread t=new Thread(nv);
- B4: Kích hoạt Thread



* isAlive(): Hàm kiểm tra xem luồng còn sống hay không
- True nếu: Gọi start nhưng chưa kết thúc hàm run
- False nếu: Kết thúc run rồi hoặc chưa start

* Concurrency: Các vấn đề đồng thời
- Khi nhiều luồng tranh giành, sử dụng chung tài nguyên: Cùng sửa 1 biến, cùng ghi 1 file...
- Các tình trạng:
+ Race Condition: Có thể ghi đè kết quả của luồng khác
+ Deadlock: Bế tắc,các luồng cùng đứng yên
- Cách giải quyết vấn đề:
+ Java cung cấp từ khóa synchronized
+ Khi mà 1 phương thức hoặc 1 đoạn code được đánh dấu Synchronize.
+ Tại 1 thời điểm chỉ có duy nhất một luồng được phép hoạt động

Hoặc sử dụng Join nhưng tạm thời chưa bàn tới